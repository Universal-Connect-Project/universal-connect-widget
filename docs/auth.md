# Authentication Layer

* It is considered that the open source widget may be hosted and consumed within one secured domain, or maybe embedded from another domain, therefore, a token-based session authentication is necessary.

* The widget is capable of routing traffics to different providers, as well as handling multiple clients' requests (when hosted by a provider). It is unavoidable that there will be complications regarding secret management, since each client will need their own registered api credentials per each provider they choose. Because of this fact, the widget needs to be able to identify the client and select the proper set of secrets. 
Therefore, it is not proper to hard-configure the credentials into the widget server. To solve this problem, the provider-specific credentials are offloaded to the clients through an auth process. A `secret exchange` flow is used during authentication to manage the secrets:
  1. The client web server (which integrates/embeds the widget) stores their own provider credentials 
  2. On a user request to load the widget, and auth token is required, at this stage, the auth server takes an additional `secret-exchange payload` while generating the token, the `secret-exchange payload` is the encrypted credential collection. The encryption is done by the client server that uses an auth-service-pre-stored key, plus an additional one-time IV that is not known by the auth-service. The auth-service responses with the Auth token, which is valid for a period of time. It is used to identify the client, as well as being the key to locate the temporary stored credentials.
  3. The above step stores the secret into the auth-service for the period of the auth token validity. The auth server itself is unable to decode it due to missing the one time IV. The client then uses the auth token, as well as the one time encryption IV, as the auth phrase to form the widget url.
  4. Once the request reaches the widget, the widget will talk to the auth service to identify the user session, get user's encryption key, and retrieves the encrypted credentials. The widget then is able to decode the credentials as it now has the key, and the one time IV, and the payload. It then makes the credentials available and only available to this particular user session. This ensures the minimal access to the credentials, which is only available for a short period of time in the widget server memory.